I asked the AI about how to share dsata (i.e. films) between users, and this is the report that got generated:

# Building a CloudKit-Based Data Sharing App

## Overview: CloudKit Sharing for Linked Data

Apple’s CloudKit provides a built-in sharing feature (via CKShare) that perfectly fits this use case. It allows one user (the owner) to share a record (your “document” with ~20 fields) from their private iCloud database with other iCloud users. Once shared, all participants have access to the same record, and any edits sync across all devices/users. In practice, a CKShare object is attached to the record to manage its sharing state, permissions, and participant list ￼. CloudKit handles the heavy lifting of syncing changes to all participants’ devices via the cloud.

At a high level, the flow is: the owner creates a share for a record and sends an invitation link (e.g. via iMessage or email). The recipient clicks the link, and iOS prompts them to join the share. If they accept, the record becomes available in their CloudKit shared database. Both users now have a “linked” copy of the data, and changes by any participant will be uploaded to CloudKit and reflected for everyone. This continues to work for additional participants as well (up to 100 per share ￼).

## Implementing Sharing with CloudKit (Universal Links)

CloudKit sharing can be implemented either with a built-in UI or manually via API:

- **Using UICloudSharingController (Recommended)**: Apple provides UICloudSharingController – a UI component that streamlines the sharing process. It handles creating the CKShare, generating the share URL, and presenting the system share sheet so the user can send the link via their chosen method (Messages, Mail, etc.). It also takes care of prompting the recipient to accept the share. To use it, enable CloudKit sharing in your app’s Info.plist (CKSharingSupported = YES) ￼. When the user taps your app’s “Share” button, you’d initialize a UICloudSharingController with the record to share (or a preparation handler that creates the CKShare) and present it. The controller will guide the user through sending the invitation link.
- **Manual Approach (CKShare API)**: Alternatively, you can directly use CloudKit APIs to share records. You would create a CKRecord for your document (often in a custom zone if you plan to share multiple related records), then create a CKShare pointing to that record. For example:

```swift
let share = CKShare(rootRecord: record)
share[CKShare.SystemFieldKey.title] = "Document Title" as CKRecordValue
share.publicPermission = .none  // (Use .none for private invites or .readWrite for public link)
```

Next, add participants to the share. You can look up a user’s iCloud identity (by email, phone, or user record ID) and fetch a CKShare.Participant for them. Then set their permission (e.g. .readWrite for collaboration) and add to the share ￼. Save the share and record together with CKModifyRecordsOperation. On success, CloudKit will provide a share URL that you can distribute ￼. Typically you’d present a UIActivityViewController to let the user send this URL via iMessage, email, etc. ￼.

**Universal Link Behavior**: The share URL that CloudKit generates is a special iCloud link (e.g. <https://www.icloud.com/share/xyz#YourApp>) which acts as a universal link to your app. On iOS, tapping this link will launch your app if installed and prompt the user with a system dialog to accept the shared item ￼. After acceptance, iOS opens your app directly to the shared data. If the app is not installed, the system will fall back to a web page or the App Store. In CloudKit’s dashboard, you can specify a fallback URL for share links ￼ – typically you’d set this to your App Store page, so that new users are directed to install the app if they don’t have it. (On Mac or unsupported OS versions, the link can also open a web preview if provided, but in most cases you’ll point to the App Store.) Bottom line: with properly configured Associated Domains and CloudKit, the iMessage/email link will deep-link into the app if possible, or guide the user to install it otherwise.

## CloudKit Sharing Permissions and Access Control

CloudKit manages share access through the CKShare object:

- The original owner of the record remains the **owner** of the share (the data stays in their private CloudKit database and counts against their iCloud storage quota ￼). The owner has full control and can remove participants or stop sharing. There must always be one owner – if the owner deletes the record or the share, it’s gone for everyone ￼.
- Users who join the share become **participants**. Each participant needs an active iCloud account (CloudKit sharing does not work with anonymous users) ￼. By default, if you invite specific people (private sharing), the participants are added with an “invite pending” status ￼. When they accept the invitation via the link, their status changes to accepted and the record will appear in their shared database ￼. At that point, all participants (including the owner) can see each other in the share’s participant list.
- **Permissions**: You can assign participants either .readOnly or .readWrite permission. In your scenario, you’d use **read-write** so that all parties can edit the shared data ￼. CloudKit ensures that only invited participants (or those with the share link, if public – see below) can access the record. Other users have no access. Security is enforced by iCloud authentication; when a participant accepts, their iCloud identity is tied to the share, and CloudKit will only allow those users (or anyone with the share URL, in case of a public share) to fetch or modify the record.
- **Participant Roles**: Invited users typically show as role privateUser (a private share participant), while the owner’s role is owner. If you enable a public share link (see next section), users who join via the link are marked as publicUser ￼. These distinctions mostly affect how they’re added (invitation vs. open link); all non-owners can be treated similarly in terms of app behavior, aside from permissions.

**How invites are sent**: CloudKit sharing does not expose personal info of participants to each other. The invitation link is the mechanism to join. You don’t manually manage authentication tokens or anything – Apple’s system UI takes care of verifying the recipient’s iCloud account when they tap the link and ensuring they become an authorized participant ￼. If you invite someone via email or phone lookup, CloudKit sends an Apple email or iMessage with the link for you (the UICloudSharingController handles this). The app can also just give the user a link to send themselves. Either way, only the intended iCloud user can actually accept and join (the link is tied to the specific invitee unless you make it public).

## Sharing with Multiple Users (Many Participants)

Your app’s sharing model should accommodate multiple collaborators on the same data. CloudKit’s CKShare supports this out of the box:

- **Adding more participants**: The share created for the data can include multiple people. The owner can invite additional users at any time (by repeating the lookup and addParticipant process for each new user, or by using the UICloudSharingController’s interface to add more people). Each new invitee gets their own link (or the same link reused) and joins the existing share. All participants will then be kept in sync on that one shared record. CloudKit currently limits a share to 100 participants maximum ￼.
- **Forwarding the link**: What if user A shares data with B, and then B wants to share with C? There are a couple of ways this can happen. If the share was set with publicPermission = .none (private), B cannot independently add C unless B is given some in-app mechanism and the authority to trigger an invite (which under the hood would still involve the owner adding C, since only owners can directly add private participants). A simpler approach is to allow a public share link: if the share’s publicPermission is set to .readWrite, anyone with the link can join the share without an explicit invite ￼. In practice, user B could just send the same iCloud share URL to user C; when C clicks it, they’ll go through the iCloud share acceptance and join as a participant (their role will be publicUser since they joined via link) ￼. All three (A, B, C) now collaborate on the one shared record. The owner (A) can still retain control — for example, they can remove participants if needed, even in a public share ￼.
- **Private vs Public sharing**: In a private share (publicPermission = .none), only specifically added people can join (the link is essentially tied to an invite). In a public share (publicPermission = .readOnly or .readWrite), any iCloud user with the link can join, making it easy to propagate among many users. Even in public shares, the data is not visible to truly anonymous parties – they must use an iCloud account to accept, and the record is still stored privately (only participants can fetch it). Choose the model based on how you expect sharing to be used. Given your description, using a share link that any recipient can open (possibly with read-write access) might be the most straightforward, since it allows the link to be shared onward to additional people without the owner manually adding each one. Just be aware that once you set a share to public, CloudKit will require new participants to use the link (the owner can no longer add new private participants to that same share) ￼. If needed, you can always include an in-app UI to toggle a share link between private and public or to generate a new share link (e.g., if you want to stop further sharing, the owner could revoke the public link by setting publicPermission = .none – note that doing so will remove all current participants except the owner ￼).

**Access management**: CloudKit handles the access control once the share is set up. Each participant’s iCloud identity is essentially their authentication. Your app doesn’t need to do special tracking beyond perhaps displaying who the collaborators are. Reading or saving the shared record uses the same CloudKit APIs as any other record, except you perform operations in the shared database (CKContainer.sharedCloudDatabase) for the participants who are not the owner. The data is protected such that outsiders (non-participants) cannot access it at all.

## Offline Usage: Viewing and Editing Data with No Connection

**Viewing Data Offline**: By default, CloudKit is a cloud-centric service – it does not automatically store data locally on the device for offline use ￼. This means that if you only use CloudKit API calls to fetch data as needed, the user wouldn’t see anything when offline. To provide a good experience, you should implement a local cache of the data. In practice, apps often store records in a local model (e.g. using Core Data, SQLite, or even in-memory) after fetching from CloudKit. For instance, when a shared record is fetched or modified, save those 20 fields in a local database (or file) on the device. This way, the user can still open the app offline and see the last known data. If you use Apple’s Core Data + CloudKit integration (NSPersistentCloudKitContainer), this offline caching is handled for you (Core Data keeps a local store in sync with CloudKit, so the data is available offline automatically ￼ ￼). But even without Core Data, you can design your data layer to save CloudKit records or their fields to local storage for offline reading.

**Editing Offline**: CloudKit supports offline edits in the sense that you can queue up changes and sync them when connectivity returns. If a user makes changes to a shared document while offline, your app should apply those changes to the local cache immediately (so the user sees the edit in the UI). Then, you need to sync it to CloudKit when possible. There are a couple of strategies:

- **Deferred save**: You could attempt to save to CloudKit immediately (even offline) by calling a CKModifyRecordsOperation. If there’s no connection, the operation will fail, but you can catch that error and retry when the network is back. Alternatively, you can detect offline status and simply mark the record as “dirty” and not even call CloudKit until later. The key is to ensure the change eventually gets sent. Apple’s CloudKit API allows operations to be long-lived (continuing in the background) if needed, but a simpler approach is to use Apple’s reachability or checks to trigger a sync when online.
- **Quality of Service and Retries**: If you do initiate a CloudKit operation with no connection, you might get a network unavailable error. CloudKit doesn’t automatically queue standard operations for later, so you’ll implement the retry logic. For robust offline support, you might store the intended modifications (e.g. the new field values) in a queue and periodically attempt to upload when the app regains connectivity (or let the user trigger a “Refresh/Sync” action).

**Conflict Handling**: Yes, users can definitely edit while offline – and if two users edit the same record simultaneously (or one offline and one online), conflicts can occur when syncing. CloudKit uses a last-writer-wins approach at the record level by default, but it provides tools for you to resolve conflicts intelligently. Each CKRecord has a system-managed change timestamp (and a change token called a recordChangeTag). If User A and User B both modify the record, whichever upload reaches CloudKit second will notice that the record was changed by someone else after it was fetched. The CloudKit server will reject the second save with a specific error (CKError.serverRecordChanged) indicating a conflict. Importantly, the error includes copies of the record: the client’s attempted record, the latest server record, and the original base record for merging ￼.

## Conflict Resolution (Merging Changes)

Since real-time updates aren’t required in your case, you can merge changes whenever a user syncs or when a conflict error arises. The merge logic lives in your app’s code – typically in the completion handler of your save operation when you detect a conflict error. Here’s how you handle it:

 1. **Detect conflict**: When you attempt to save a record via CKModifyRecordsOperation, use .ifServerRecordUnchanged save policy (the default) to avoid silent overwrites. If a conflict is found, CloudKit returns a CKError.serverRecordChanged. The error’s userInfo will contain: the record you tried to save (ClientRecord), the current record on the server (ServerRecord, which includes the other user’s changes), and the original record as you last fetched it (AncestorRecord) ￼.
 2. **Merge changes**: Your app should merge the changes in a way that makes sense for your data. The simplest strategy is often “last writer wins” (just take the server record or the client record based on timestamps) – but that could overwrite someone’s changes unintentionally. A better strategy is to do a field-by-field merge if possible. For example, if your document has 20 fields and different users edited different fields, you can combine those edits. The official guidance is to apply your local changes onto the latest server record and then save that combined record ￼. In practice, you would compare the ServerRecord and ClientRecord: for each field, decide whose value to keep – e.g., if the fields don’t conflict, keep both sets of changes; if the same field was changed by both, decide which one “wins” (perhaps the latest timestamp, or you could prompt the user in complex cases). You then call save again with this merged record. CloudKit will accept it because you’re now basing it on the latest version (you’ll have updated the record’s change tag by using the server copy as base).
 3. **Implementing merge logic**: You can implement this in the modify records operation’s completion block. If error is serverRecordChanged, retrieve the CKRecord from error.userInfo[CKRecordChangedErrorServerRecordKey] and the one from CKRecordChangedErrorClientRecordKey. Merge their fields as needed in a new CKRecord (or modify the server one’s fields) and attempt another save ￼. CloudKit also provides a convenience CKModifyRecordsOperation.SavePolicy.changedKeys which, if used, will only apply the fields you’ve modified, potentially reducing conflicts. For instance, if you set .changedKeys save policy, CloudKit will try to update only the keys that your record has changed, and leave others untouched – this can automatically handle some scenarios where two users edited different fields. However, if the same field was touched by both, you’ll still get a conflict. So, robust conflict resolution often requires the custom merging described above.
 4. **No real-time requirement**: Because you don’t need instant conflict resolution, you might choose to resolve conflicts at the time of syncing (e.g., when the user comes back online or performs a manual sync). You could also use CKFetchRecordZoneChanges or CKQuerySubscriptions to periodically fetch new changes from CloudKit and merge them into the local data. Without real-time, a practical approach is: whenever the app launches or becomes active, fetch the latest changes for any shared records and update the local cache. If an automatic push (subscription) is set up, you could also trigger a fetch on notification.

CloudKit’s conflict handling is client-driven – you decide the merge policy that makes sense for your data model ￼ ￼. For example, if this data is like a document where field-by-field merge is logical, implement that. If it’s simpler (maybe only one user is likely to edit at a time), you might choose to always take the latest change. The key is to ensure all participants eventually end up with a consistent record after everyone’s changes are applied.

## Summary: CloudKit Sharing in Your App

Using CloudKit for this scenario means you don’t have to build server logic for data sync – Apple’s infrastructure will propagate record changes to all users’ iCloud copies. You will need to wire up the sharing flow in your app (either via Apple’s UICloudSharingController or manually creating CKShare links), handle the case where the app isn’t installed (with App Store fallback via the universal link), and implement local caching for offline use. Data “linked” between users is achieved through the shared CKRecord; every participant is essentially pointing to the same record on Apple’s servers. When online, each edit one user makes will be sync’ed to iCloud and then down to the others (you can use CloudKit subscriptions to get push notifications of changes, or just pull updates periodically). When offline, users can still view and modify cached data; those changes can be queued and later synced to iCloud. CloudKit ensures that once synced, all users see the updates, and it provides the tools (change tokens, record change tags, error info) to resolve any concurrent-edit conflicts in your app’s logic.

By leveraging CloudKit sharing, you get a robust foundation for collaborative data with managed access control. The feature is designed exactly for use cases like “send a link to share data, open in app, keep in sync”. All you need is to implement the above client-side logic, and you’ll have an app where users can seamlessly share data via iMessage/email and enjoy a synchronized experience across many users.

**Sources**: CloudKit sharing documentation and developer experiences were used to compile this information. Key references include Apple’s CloudKit sharing guides and real-world usage write-ups (e.g., how a CKShare manages participants and permissions ￼ ￼ ￼, handling CloudKit data offline ￼, and Apple’s recommendations on conflict resolution in CloudKit ￼).
